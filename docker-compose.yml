services:
  e-commerce-store:
    build:
      context: .
      dockerfile: Dockerfile # To jest Dockerfile dla środowiska Node 24
      target: test_runner
    container_name: e-commerce-store
    volumes:
      - .:/workspace # bind mount – cały katalog hosta jest współdzielony z kontenerem (w tym node_modules)

      # Jeśli użyje się w volumes dodakowo anonimowego volumenu to operacje npm install są znacznie szybsze, bo nie muszą synchronizować tysięcy małych plików między kontenerem a Windowsem/Macem przez system plików.
      # Jeśli zrobisz docker compose down, kontenery są usuwane, ALE anonimowe wolumeny (te, w których masz node_modules) nadal zostają w pamięci Dockera, dopóki nie użyjesz flagi -v.
      # - /workspace/node_modules # Anonimowy wolumen dla szybkości
      # Poniższe polecenie montuje socket SSH agenta z hosta do kontenera, żeby można było używać kluczy SSH bez kopiowania ich do kontenera

      # Montowanie socketu SSH agenta – kontener może używać kluczy SSH hosta
      # bez kopiowania ich do środka (bezpieczniejsze git push/pull)
      # MAPOWANIE SOCKETU AGENTA SSH:
      # Pozwala kontenerowi "rozmawiać" z agentem SSH uruchomionym na systemie (hoście).
      # Dzięki temu Git w kontenerze użyje prywatnych kluczy do uwierzytelnienia (np. przy git push),
      # ale same klucze fizycznie nigdy nie zostaną skopiowane do środka kontenera.
      - ${SSH_AUTH_SOCK}:/run/host-services/ssh-auth.sock
      # Montuje lokalny plik gitconfig do kontenera w trybie tylko do odczytu, żeby zachować konfigurację użytkownika git
      # MAPOWANIE KONFIGURACJI GITA:
      # Montuje lokalny plik .gitconfig w trybie tylko do odczytu (:ro).
      # Dzięki temu w kontenerze od razu jest ustawione swoje Imię, Nazwisko i Email autora commitów.
      # Tryb :ro chroni główny plik przed przypadkową zmianą z wnętrza kontenera.
      - ~/.gitconfig:/home/node/.gitconfig:ro
        # ZAUFANE HOSTY SSH:
      # Mapuje listę znanych hostów (np. github.com, bitbucket.org) z Twojego systemu do kontenera.
      # Dzięki temu SSH w kontenerze od razu "ufa" serwerom, które już znasz na hoście.
      # Eliminuje to interaktywne pytania "Are you sure you want to continue connecting?"
      # podczas operacji Git (push/pull) i pozwala na pełną automatyzację pracy.
      - ~/.ssh/known_hosts:/home/node/.ssh/known_hosts:ro
    working_dir: /workspace/app
    # Zapis user: "${USER_ID}:${GROUP_ID}" mówi Dockerowi: "Nie uruchamiaj tego kontenera jako root, ale jako konkretny użytkownik o takich numerach ID".
    user: "${USER_ID}:${GROUP_ID}"
    # group_add: ["1000"] – pozwala użytkownikowi node (wewnątrz kontenera) uzyskać dostęp do socketu agenta SSH z hosta.
    group_add:
      # - "1000" # Stałe ID grupy (często domyślne dla użytkownika/dockera na wielu systemach)
      - "${GROUP_ID}" # Dynamiczne ID grupy Twojego aktualnego użytkownika
      # Pozwala użytkownikowi node czytać socket SSH należący do roota/systemu
      # Kontenerowy użytkownik nadal UID=1000, GID=1001, ale jest dodatkowo w grupie 1000.
      # Teraz może czytać socket hosta (bo należy do grupy, która ma prawa do socketu).
    environment:
      # ZMIENNA ŚRODOWISKOWA SSH:
      # Wskazuje narzędziom w kontenerze (np. Gitowi), gdzie dokładnie znajduje się zamontowany socket.
      # Bez tej zmiennej Git nie wiedziałby, przez który "plik" ma się komunikować z Twoim agentem SSH,
      # i pytałby o hasło lub odrzucił połączenie przy próbie wypchnięcia zmian.
      # Ustawia zmienną środowiskową w kontenerze, aby narzędzia SSH (np. git push/pull) wiedziały, gdzie jest socket agenta. To MUSI być tutaj - bez tego tunel fizycznie nie powstanie:
      - SSH_AUTH_SOCK=/run/host-services/ssh-auth.sock # Agent SSH nie jest częścią kontenera, więc jeśli usuniesz kontener, agent na hoście nadal działa. Socket/tunel w kontenerze zniknie razem z kontenerem, ale sam proces agenta hostowego pozostaje aktywny.
    tty: true # Wirtualny terminal. Utrzymuje kontener aktywnym(bez niego kontener od razu może się zakońćzyć), ułatwia debug i kolorowy output.
    # stdin_open: true  # pozwala na otwarcie stdin, czyli interakcję z kontenerem, bez stdin nie można robić interaktywnych rzeczy typu podłączenie się do kontenera i pisanie w konsoli. - nie potrzbene bo wchodze przez -it
    ports:
      - "3000:3000" # Mapuje port 3000 z kontenera na port 3000 hosta.
    # Jeśli port w kontenerze jest zajęty (np. dev server już wystartował automatycznie),
    # Vite/Next następnym npm run dev może próbować kolejnych wolnych portów (3001, 3002…),
    # ale te nie są mapowane na hosta, więc w przeglądarce widzisz tylko localhost:3000.
    env_file:
      - .env
    # command: ["npm", "run", "dev"]
  # LOGIKA PORTÓW (Docker Proxy):
  # ----------------------------
  # 1. Gdy kontener jest 'Up', proces 'docker-proxy' REZERWUJE port 3000 na Twoim hoście (WSL).
  # 2. Nawet jeśli powyższy 'command' jest zakomentowany (dev server w kontenerze nie działa), port na hoście jest ZAJĘTY.
  # 3. Skutek: Lokalne 'npm run dev' w WSL wykrywa zajęty port i przeskakuje na 3001 (konflikt z Dockerem).
  # 4. Wewnątrz kontenera port 3000 pozostaje WOLNY, dopóki nie uruchomisz tam ręcznie 'npm run dev'.
  # ROZWIĄZANIE: Aby używać portu 3000 lokalnie w WSL, najpierw zatrzymaj kontener: 'docker compose stop e-commerce-store'.

  e2e-tests:
    image: mcr.microsoft.com/playwright:v1.58.2-noble
    container_name: e2e-tests
    volumes:
      - .:/workspace # bind mount – cały katalog hosta jest współdzielony z kontenerem (w tym node_modules)
    working_dir: /workspace/app
    # depends_on w Docker Compose sprawdza tylko, czy kontener wystartował, a nie czy aplikacja (np. Next.js/Vite) wewnątrz niego zakończyła proces budowania i nasłuchuje na porcie. wait-on wypełnia tę lukę.
    depends_on:
      - e-commerce-store
    env_file:
      - .env
    user: "${USER_ID}:${GROUP_ID}" # "0:0" - uruchamia kontener jako root tylko do testów e2e
    tty: true # Wirtualny terminal. Utrzymuje kontener aktywnym(bez niego kontener od razu może się zakońćzyć), ułatwia debug i kolorowy output.
    # stdin_open: true  # pozwala na otwarcie stdin, czyli interakcję z kontenerem, bez stdin nie można robić interaktywnych rzeczy typu podłączenie się do kontenera i pisanie w konsoli. - nie potrzbene bo wchodze przez it
    # TRYB AUTOMATYCZNY: odkomentuj linię poniżej
    # command: ["sh", "-c", "npx wait-on $PLAYWRIGHT_BASE_URL && npx playwright test ./e2e; tail -f /dev/null"]
    # TRYB RĘCZNY: kontener czeka, testy uruchamiasz ręcznie
    # command: ["tail", "-f", "/dev/null"]
    command:
      [
        "sh",
        "-c",
        "npx wait-on http://e-commerce-store:3000 && tail -f /dev/null",
      ]

    # Testy E2E (Playwright) zostały usunięte z Dockerfile – słusznie, bo E2E najlepiej uruchamiać po uruchomieniu kontenera frontendowego, np. w docker-compose jako osobny serwis. Dzięki temu nie blokują builda i nie wymagają uruchamiania frontendu w tle w czasie builda.
