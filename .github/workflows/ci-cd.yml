name: Feature Branch - Docker Build # Nazwa workflow

on:
  pull_request:
    branches: ["develop", "main"] # Wyzwala workflow przy PR do develop lub main
  # Brak wyzwalania workflow przy zwykłym pushu do branchy,
  # aby nie budować ani testować obrazu przy każdym pushu czy merge request.
  push:
    tags:
      - "*" # Wyzwala workflow przy pushu tagów

permissions:
  packages: write # Pozwala workflow publikować obrazy w GHCR

jobs:
  build_docker: # Job do budowania i publikowania obrazu Docker
    runs-on: ubuntu-latest # Uruchamiany na maszynie Ubuntu
    outputs: # Outputy joba, które mogą być użyte w innych jobach
      # steps – odwołanie do kroków w tym jobie
      # set_repo – id kroku, który produkuje output
      # outputs.gh_repo_lc – nazwa outputu zdefiniowanego w kroku
      GH_REPO_LC: ${{ steps.set_repo.outputs.gh_repo_lc }} # Nazwa repo w małych literach
      TAG_NAME: ${{ steps.set_tag.outputs.tag_name }} # Nazwa tagu obrazu
    steps:
      - name: Checkout code
        uses: actions/checkout@v4 # Pobiera kod repozytorium na runnera

      - name: Set lower case Github repository name
        id: set_repo # ID kroku, wymagane, by ustawić output
        run: |
          # Tworzymy zmienną w małych literach z nazwy repozytorium
          echo "gh_repo_lc=${GITHUB_REPOSITORY,,}" >> $GITHUB_ENV
          # Zapis do output kroku, aby można było przekazać do innego joba
          echo "gh_repo_lc=${GITHUB_REPOSITORY,,}" >> $GITHUB_OUTPUT
        env:
          GITHUB_REPOSITORY: ${{ github.repository }} # Nazwa repo

      - name: Set proper tag name for Docker image
        id: set_tag # ID kroku do outputu
        run: |
          # Zamiana liter na małe i '/' na '-', bo GHCR wymaga małych liter w tagach
          TAG_NAME_LOWER=$(echo "${GITHUB_REF_NAME,,}" | sed 's|/|-|g')
          # Zapis do $GITHUB_ENV dla użycia w tym jobie
          echo "tag_name=$TAG_NAME_LOWER" >> $GITHUB_ENV
          # Zapis do output kroku, aby przekazać do innego joba
          echo "tag_name=$TAG_NAME_LOWER" >> $GITHUB_OUTPUT
        env:
          GITHUB_REF_NAME: ${{ github.ref_name }} # Nazwa branch/tag wyzwalającego workflow

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3 # Konfiguracja Buildx dla multi-architektury

      - name: Login to Github Container Registry
        uses: docker/login-action@v3 # Logowanie do GHCR
        with:
          registry: ghcr.io # Adres rejestru
          username: ${{ github.actor }} # Użytkownik GitHub
          password: ${{ secrets.GITHUB_TOKEN }} # Token do logowania

      - name: Build Docker image
        uses: docker/build-push-action@v3 # Buduje i wysyła obraz Docker
        with:
          context: . # Kontekst builda (root repo)
          file: ./Dockerfile # Plik Dockerfile
          push: true # Wysyła obraz do GHCR
          # Generowanie atestacji zgodnie ze standardem SLSA (Supply-chain Levels for Software Artifacts).
          # sbom: Tworzy pełną listę składników obrazu (Software Bill of Materials) dla lepszego audytu bezpieczeństwa.
          # provenance: Zapisuje pełną historię budowania obrazu, co pozwala na weryfikację jego pochodzenia w Docker Scout.
          sbom: true
          # Użycie outputów kroków do utworzenia tagu obrazu
          tags: ghcr.io/${{ steps.set_repo.outputs.gh_repo_lc }}:${{ steps.set_tag.outputs.tag_name }}

  secure_scan: # Job do skanowania obrazu Docker (Trivy)
    runs-on: ubuntu-latest # Uruchamiany na Ubuntu
    needs: build_docker # Wykonuje się dopiero po build_docker
    if: github.event_name == 'push' && startsWith(github.ref, 'refs/tags/') # Tylko przy pushu tagów
    steps:
      - name: Trivy Scan
        uses: aquasecurity/trivy-action@master # Skanowanie obrazu Trivy
        with:
          # Odwołanie do outputów joba build_docker
          # needs.build_docker – job, który musi się zakończyć wcześniej
          # outputs.GH_REPO_LC – output joba build_docker
          image-ref: ghcr.io/${{ needs.build_docker.outputs.GH_REPO_LC }}:${{ needs.build_docker.outputs.TAG_NAME }}
          format: "table" # Format tabeli
          exit-code: "1" # Exit code przy krytycznych/wysokich podatnościach
          ignore-unfixed: true # Ignoruje podatności, które nie mają poprawki
          vuln-type: os,library # Skanuje OS i biblioteki
          severity: "CRITICAL,HIGH" # Skupia się na krytycznych i wysokich podatnościach
        env:
          TRIVY_USERNAME: ${{ github.actor }} # Tymczasowe dane logowania
          TRIVY_PASSWORD: ${{ secrets.GITHUB_TOKEN }} # Token do logowania

  # Testy E2E na produkcyjnym obrazie Docker
  # - Uruchamiane w trybie headless przy użyciu Playwright
  # - Wyzwalane tylko przy puszu tagów (czyli dla release'ów/wersji produkcyjnych, a nie przy PR ani zwykłych pushach do branchy)
  # Cel: sprawdzenie, czy zbudowany obraz działa poprawnie w produkcji i czy aplikacja działa w przeglądarce
  e2e_production_check: # Nazwa joba
    runs-on: ubuntu-latest # Job będzie wykonywany na maszynie wirtualnej Ubuntu
    needs: [build_docker] # Ten job wykona się dopiero po zakończeniu joba 'build_docker'
    if: github.event_name == 'push' && startsWith(github.ref, 'refs/tags/')
    # Job uruchamia się tylko przy pushu tagów (release), nie przy PR ani zwykłych pushach
    steps: # Lista kroków w jobie
      - name: Checkout code
        uses: actions/checkout@v4 # Pobiera kod repozytorium na runnera, aby mieć dostęp do plików potrzebnych do testów

      - name: Login to Github Container Registry
        uses: docker/login-action@v3 # Akcja logowania do Docker Registry (GHCR)
        with:
          registry: ghcr.io # Logowanie do GitHub Container Registry
          username: ${{ github.actor }} # Używa loginu użytkownika GitHub, który uruchamia workflow
          password: ${{ secrets.GITHUB_TOKEN }} # Token GitHub do uwierzytelnienia, przechowywany w secrets

      - name: Run Production Image
        run: | # Blok poleceń shell
          docker run -d -p 8080:8080 --name prod_app ghcr.io/${{ needs.build_docker.outputs.GH_REPO_LC }}:${{ needs.build_docker.outputs. TAG_NAME }}
           # Uruchamia zbudowany obraz Docker w tle (-d), mapuje port 8080 kontenera na hosta
            # docker run -> uruchamia kontener
      # run -> to odpowiednik uruchomienia serwera, tylko w kontenerze produkcyjnym dla potrzeb testów, więc Playwright nie potrzebuje w tym przypadku opcji webServer
      # docker run - > uruchamienie kontenera produkcyjnego z gotowym z obrazem
      # Uruchamia kontener produkcyjny w tle (-d)
      # Mapuje port 8080 kontenera na hosta (-p 8080:8080)
      # Nadaje kontenerowi nazwę 'prod_app' (--name)
      # Obraz pochodzi z GHCR, używa outputów joba build_docker (repo + tag)
      # Cel: mieć działającą produkcyjną wersję aplikacji, na której Playwright może wykonywać testy
      # Dzięki temu Playwright nie potrzebuje opcji webServer w tym jobie

      - name: Install dependencies
        run: npm ci # Instalacja zależności Node w trybie CI
        working-directory: ./app # Katalog, w którym wykona się polecenie

      - name: Install Playwright Browsers
        run: npx playwright install --with-deps # Instalacja wszystkich przeglądarek i zależności systemowych dla Playwright
        working-directory: ./app # Katalog, w którym polecenie się wykona
      # Instalacja wszystkich zależności Node w katalogu app w czystym trybie CI (npm ci)
      # Cel: upewnić się, że testy E2E mają wszystkie potrzebne paczki
      - name: Run E2E Tests against Docker
        run: npm run test:e2e-ci # Uruchamia testy E2E zdefiniowane w package.json
        env:
          PLAYWRIGHT_BASE_URL: http://localhost:8080 # URL aplikacji, na której będą testy
          PLAYWRIGHT_SKIP_WEBSERVER: 1 # Nie uruchamiaj lokalnego serwera dev (aplikacja już działa)
        working-directory: ./app # Katalog, w którym wykonywane są testy
        # Instalacja przeglądarek (Chromium, Firefox, WebKit) i dodatkowych zależności systemowych wymaganych przez Playwright
        # Cel: Playwright może uruchomić testy w trybie headless

      - name: Upload Playwright Report
        uses: actions/upload-artifact@v4 # Akcja przesyłania artefaktu do GitHub Actions
        if: always()
        # Wykonaj nawet jeśli testy zakończą się błędem
        with:
          name: playwright-production-report # Nazwa artefaktu
          path: app/playwright-report/ # Ścieżka do katalogu z raportem
          retention-days: 30 # Czas przechowywania artefaktu w dniach
      # Zawsze (if always()) przesyła raport Playwright do GitHub Actions jako artifact
      # Umożliwia późniejsze pobranie raportu, nawet jeśli testy zakończą się błędem
      # Retention-days=30 -> raport jest przechowywany przez 30 dni
